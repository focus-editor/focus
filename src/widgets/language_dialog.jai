language_dialog_handle_event :: (event: Input.Event) -> handled: bool {
    return dialog_handle_event(*language_dialog, event);
}

language_dialog: Language_Dialog;

Language_Dialog :: struct {
    using #as generic_dialog: Generic_Choice_Dialog(Language);
    generic_dialog.global_widget_id    = .language_dialog;
    generic_dialog.refresh_entries     = language_dialog_refresh_entries;
    generic_dialog.open_entry_in_place = apply_selected_language;
    generic_dialog.on_show             = language_dialog_on_show;
}

#scope_file

apply_selected_language :: () {
    using language_dialog;
    defer hide_dialog(*language_dialog);

    if build_panel_is_active() return;  // shouldn't ever be active

    if selected >= filtered.count return;

    _, buffer := get_active_editor_and_buffer();
    if !buffer return;

    result := filtered[selected];
    buffer.lang = result.details.value;

    // No need to create a tokenizer for plaintext, just reset the token array
    if buffer.lang == .Plain_Text {
        lock(*buffer.content_lock);
        array_reset_keeping_memory(*buffer.regions);
        array_resize(*buffer.tokens, buffer.bytes.count);
        memset(buffer.tokens.data, 0, buffer.tokens.count);
        unlock(*buffer.content_lock);
    }

    retokenize(buffer);
}

language_dialog_on_show :: () {
    hide_build_panel();
}

language_dialog_refresh_entries :: (filter: Fuzzy_Filter) {
    using language_dialog;

    editor, buffer := get_active_editor_and_buffer();
    if !editor || !buffer then return;

    langs := #run language_dialog_get_languages();

    for * lang: langs {
        score, highlights := fuzzy_match(lang.name, filter);
        if score <= 0 && filter.full_string continue;

        entry := array_add(*filtered);
        entry.highlights = highlights;
        entry.sort_key = cast(u64) score;

        // Sort current language on top when we first open the dialog
        if !filter.full_string && lang.value == buffer.lang {
            lang.active = true;
            entry.sort_key |= cast(u64) 1 << 62;
        }

        entry.details = lang;
    }
}

language_dialog_get_languages :: () -> [] Language {
    languages: [..] Language;

    lang_names := enum_names(Buffer.Lang);
    lang_values := enum_values_as_enum(Buffer.Lang);

    for lang_names array_add(*languages, .{name = replace(it, "_", " "), value = lang_values[it_index]});

    return languages;
}

Language :: struct {
    active: bool = false;
    name: string;
    value: Buffer.Lang;
}
