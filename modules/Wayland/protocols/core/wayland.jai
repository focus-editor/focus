/*
 * Auto-generated by `wayland-scanner` version 1.0.1
 * Protocol: wayland
 */

wl_display_interface: wl_interface;
wl_display :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_display_interface;

    connect                :: wl_display_connect;
    connect_to_fd          :: wl_display_connect_to_fd;
    disconnect             :: wl_display_disconnect;
    get_fd                 :: wl_display_get_fd;
    dispatch               :: wl_display_dispatch;
    dispatch_queue         :: wl_display_dispatch_queue;
    dispatch_queue_pending :: wl_display_dispatch_queue_pending;
    dispatch_pending       :: wl_display_dispatch_pending;
    get_error              :: wl_display_get_error;
    get_protocol_error     :: wl_display_get_protocol_error;
    flush                  :: wl_display_flush;
    roundtrip_queue        :: wl_display_roundtrip_queue;
    roundtrip              :: wl_display_roundtrip;
    create_queue           :: wl_display_create_queue;
    prepare_read_queue     :: wl_display_prepare_read_queue;
    prepare_read           :: wl_display_prepare_read;
    cancel_read            :: wl_display_cancel_read;
    read_events            :: wl_display_read_events;

    /* ENUM: wl_display::error */
    error_invalid_object : u32 : 0;
    error_invalid_method : u32 : 1;
    error_no_memory      : u32 : 2;
    error_implementation : u32 : 3;

    set_user_data :: inline (self: *wl_display, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_display) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_display) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    sync :: inline (self: *wl_display) -> *wl_callback #c_call {
        ret: *wl_proxy = wl_proxy.marshal_flags(
            self, WL_DISPLAY_SYNC,
            *wl_callback_interface, wl_proxy.get_version(self), 0,
            null);
        return cast(*wl_callback) ret;
    }

    get_registry :: inline (self: *wl_display) -> *wl_registry #c_call {
        ret: *wl_proxy = wl_proxy.marshal_flags(
            self, WL_DISPLAY_GET_REGISTRY,
            *wl_registry_interface, wl_proxy.get_version(self), 0,
            null);
        return cast(*wl_registry) ret;
    }

    add_listener :: inline (self: *wl_display, listener: *wl_display_listener, data: *void) -> s32 #c_call {
        return wl_proxy.add_listener(self, cast(*generic_c_call) listener, data);
    }
}

WL_DISPLAY_SYNC               : u32 : 0;
WL_DISPLAY_GET_REGISTRY       : u32 : 1;
WL_DISPLAY_SYNC_SINCE         : u32 : 1;
WL_DISPLAY_GET_REGISTRY_SINCE : u32 : 1;
WL_DISPLAY_ERROR_SINCE        : u32 : 1;
WL_DISPLAY_DELETE_ID_SINCE    : u32 : 1;

wl_display_listener :: struct {
    error     := _stubs_.error;
    delete_id := _stubs_.delete_id;

    _stubs_ :: struct {
        error :: (data: *void,
            self: *wl_display,
            object_id: *void,
            code: u32,
            message: *u8) -> void #c_call {}
        delete_id :: (data: *void,
            self: *wl_display,
            id: u32) -> void #c_call {}
    }
}

wl_registry_interface: wl_interface;
wl_registry :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_registry_interface;

    set_user_data :: inline (self: *wl_registry, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_registry) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_registry) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *wl_registry) #c_call {
        wl_proxy.destroy(self);
    }

    bind :: inline (self: *wl_registry, name: u32, intf: *wl_interface, version: u32) -> *void #c_call {
        ret: *wl_proxy = wl_proxy.marshal_flags(
            self, WL_REGISTRY_BIND,
            intf, version, 0,
            name, intf.name, version, null);
        return cast(*void) ret;
    }

    add_listener :: inline (self: *wl_registry, listener: *wl_registry_listener, data: *void) -> s32 #c_call {
        return wl_proxy.add_listener(self, cast(*generic_c_call) listener, data);
    }
}

WL_REGISTRY_BIND                : u32 : 0;
WL_REGISTRY_BIND_SINCE          : u32 : 1;
WL_REGISTRY_GLOBAL_SINCE        : u32 : 1;
WL_REGISTRY_GLOBAL_REMOVE_SINCE : u32 : 1;

wl_registry_listener :: struct {
    global        := _stubs_.global;
    global_remove := _stubs_.global_remove;

    _stubs_ :: struct {
        global :: (data: *void,
            self: *wl_registry,
            name: u32,
            _interface: *u8,
            version: u32) -> void #c_call {}
        global_remove :: (data: *void,
            self: *wl_registry,
            name: u32) -> void #c_call {}
    }
}

wl_callback_interface: wl_interface;
wl_callback :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_callback_interface;

    set_user_data :: inline (self: *wl_callback, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_callback) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_callback) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *wl_callback) #c_call {
        wl_proxy.destroy(self);
    }

    add_listener :: inline (self: *wl_callback, listener: *wl_callback_listener, data: *void) -> s32 #c_call {
        return wl_proxy.add_listener(self, cast(*generic_c_call) listener, data);
    }
}

WL_CALLBACK_DONE_SINCE : u32 : 1;

wl_callback_listener :: struct {
    done := _stubs_.done;

    _stubs_ :: struct {
        done :: (data: *void,
            self: *wl_callback,
            callback_data: u32) -> void #c_call {}
    }
}

wl_compositor_interface: wl_interface;
wl_compositor :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_compositor_interface;

    set_user_data :: inline (self: *wl_compositor, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_compositor) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_compositor) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *wl_compositor) #c_call {
        wl_proxy.destroy(self);
    }

    create_surface :: inline (self: *wl_compositor) -> *wl_surface #c_call {
        ret: *wl_proxy = wl_proxy.marshal_flags(
            self, WL_COMPOSITOR_CREATE_SURFACE,
            *wl_surface_interface, wl_proxy.get_version(self), 0,
            null);
        return cast(*wl_surface) ret;
    }

    create_region :: inline (self: *wl_compositor) -> *wl_region #c_call {
        ret: *wl_proxy = wl_proxy.marshal_flags(
            self, WL_COMPOSITOR_CREATE_REGION,
            *wl_region_interface, wl_proxy.get_version(self), 0,
            null);
        return cast(*wl_region) ret;
    }
}

WL_COMPOSITOR_CREATE_SURFACE       : u32 : 0;
WL_COMPOSITOR_CREATE_REGION        : u32 : 1;
WL_COMPOSITOR_CREATE_SURFACE_SINCE : u32 : 1;
WL_COMPOSITOR_CREATE_REGION_SINCE  : u32 : 1;

wl_shm_pool_interface: wl_interface;
wl_shm_pool :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_shm_pool_interface;

    set_user_data :: inline (self: *wl_shm_pool, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_shm_pool) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_shm_pool) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    create_buffer :: inline (self: *wl_shm_pool, offset: s32, width: s32, height: s32, stride: s32, format: u32) -> *wl_buffer #c_call {
        ret: *wl_proxy = wl_proxy.marshal_flags(
            self, WL_SHM_POOL_CREATE_BUFFER,
            *wl_buffer_interface, wl_proxy.get_version(self), 0,
            null, offset, width, height, stride, format);
        return cast(*wl_buffer) ret;
    }

    destroy :: inline (self: *wl_shm_pool) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SHM_POOL_DESTROY,
            null, wl_proxy.get_version(self), WL_MARSHAL_FLAG_DESTROY);
    }

    resize :: inline (self: *wl_shm_pool, size: s32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SHM_POOL_RESIZE,
            null, wl_proxy.get_version(self), 0,
            size);
    }
}

WL_SHM_POOL_CREATE_BUFFER       : u32 : 0;
WL_SHM_POOL_DESTROY             : u32 : 1;
WL_SHM_POOL_RESIZE              : u32 : 2;
WL_SHM_POOL_CREATE_BUFFER_SINCE : u32 : 1;
WL_SHM_POOL_DESTROY_SINCE       : u32 : 1;
WL_SHM_POOL_RESIZE_SINCE        : u32 : 1;

wl_shm_interface: wl_interface;
wl_shm :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_shm_interface;

    /* ENUM: wl_shm::error */
    error_invalid_format : u32 : 0;
    error_invalid_stride : u32 : 1;
    error_invalid_fd     : u32 : 2;

    /* ENUM: wl_shm::format */
    format_argb8888             : u32 : 0;
    format_xrgb8888             : u32 : 1;
    format_c8                   : u32 : 0x20203843;
    format_rgb332               : u32 : 0x38424752;
    format_bgr233               : u32 : 0x38524742;
    format_xrgb4444             : u32 : 0x32315258;
    format_xbgr4444             : u32 : 0x32314258;
    format_rgbx4444             : u32 : 0x32315852;
    format_bgrx4444             : u32 : 0x32315842;
    format_argb4444             : u32 : 0x32315241;
    format_abgr4444             : u32 : 0x32314241;
    format_rgba4444             : u32 : 0x32314152;
    format_bgra4444             : u32 : 0x32314142;
    format_xrgb1555             : u32 : 0x35315258;
    format_xbgr1555             : u32 : 0x35314258;
    format_rgbx5551             : u32 : 0x35315852;
    format_bgrx5551             : u32 : 0x35315842;
    format_argb1555             : u32 : 0x35315241;
    format_abgr1555             : u32 : 0x35314241;
    format_rgba5551             : u32 : 0x35314152;
    format_bgra5551             : u32 : 0x35314142;
    format_rgb565               : u32 : 0x36314752;
    format_bgr565               : u32 : 0x36314742;
    format_rgb888               : u32 : 0x34324752;
    format_bgr888               : u32 : 0x34324742;
    format_xbgr8888             : u32 : 0x34324258;
    format_rgbx8888             : u32 : 0x34325852;
    format_bgrx8888             : u32 : 0x34325842;
    format_abgr8888             : u32 : 0x34324241;
    format_rgba8888             : u32 : 0x34324152;
    format_bgra8888             : u32 : 0x34324142;
    format_xrgb2101010          : u32 : 0x30335258;
    format_xbgr2101010          : u32 : 0x30334258;
    format_rgbx1010102          : u32 : 0x30335852;
    format_bgrx1010102          : u32 : 0x30335842;
    format_argb2101010          : u32 : 0x30335241;
    format_abgr2101010          : u32 : 0x30334241;
    format_rgba1010102          : u32 : 0x30334152;
    format_bgra1010102          : u32 : 0x30334142;
    format_yuyv                 : u32 : 0x56595559;
    format_yvyu                 : u32 : 0x55595659;
    format_uyvy                 : u32 : 0x59565955;
    format_vyuy                 : u32 : 0x59555956;
    format_ayuv                 : u32 : 0x56555941;
    format_nv12                 : u32 : 0x3231564e;
    format_nv21                 : u32 : 0x3132564e;
    format_nv16                 : u32 : 0x3631564e;
    format_nv61                 : u32 : 0x3136564e;
    format_yuv410               : u32 : 0x39565559;
    format_yvu410               : u32 : 0x39555659;
    format_yuv411               : u32 : 0x31315559;
    format_yvu411               : u32 : 0x31315659;
    format_yuv420               : u32 : 0x32315559;
    format_yvu420               : u32 : 0x32315659;
    format_yuv422               : u32 : 0x36315559;
    format_yvu422               : u32 : 0x36315659;
    format_yuv444               : u32 : 0x34325559;
    format_yvu444               : u32 : 0x34325659;
    format_r8                   : u32 : 0x20203852;
    format_r16                  : u32 : 0x20363152;
    format_rg88                 : u32 : 0x38384752;
    format_gr88                 : u32 : 0x38385247;
    format_rg1616               : u32 : 0x32334752;
    format_gr1616               : u32 : 0x32335247;
    format_xrgb16161616f        : u32 : 0x48345258;
    format_xbgr16161616f        : u32 : 0x48344258;
    format_argb16161616f        : u32 : 0x48345241;
    format_abgr16161616f        : u32 : 0x48344241;
    format_xyuv8888             : u32 : 0x56555958;
    format_vuy888               : u32 : 0x34325556;
    format_vuy101010            : u32 : 0x30335556;
    format_y210                 : u32 : 0x30313259;
    format_y212                 : u32 : 0x32313259;
    format_y216                 : u32 : 0x36313259;
    format_y410                 : u32 : 0x30313459;
    format_y412                 : u32 : 0x32313459;
    format_y416                 : u32 : 0x36313459;
    format_xvyu2101010          : u32 : 0x30335658;
    format_xvyu12_16161616      : u32 : 0x36335658;
    format_xvyu16161616         : u32 : 0x38345658;
    format_y0l0                 : u32 : 0x304c3059;
    format_x0l0                 : u32 : 0x304c3058;
    format_y0l2                 : u32 : 0x324c3059;
    format_x0l2                 : u32 : 0x324c3058;
    format_yuv420_8bit          : u32 : 0x38305559;
    format_yuv420_10bit         : u32 : 0x30315559;
    format_xrgb8888_a8          : u32 : 0x38415258;
    format_xbgr8888_a8          : u32 : 0x38414258;
    format_rgbx8888_a8          : u32 : 0x38415852;
    format_bgrx8888_a8          : u32 : 0x38415842;
    format_rgb888_a8            : u32 : 0x38413852;
    format_bgr888_a8            : u32 : 0x38413842;
    format_rgb565_a8            : u32 : 0x38413552;
    format_bgr565_a8            : u32 : 0x38413542;
    format_nv24                 : u32 : 0x3432564e;
    format_nv42                 : u32 : 0x3234564e;
    format_p210                 : u32 : 0x30313250;
    format_p010                 : u32 : 0x30313050;
    format_p012                 : u32 : 0x32313050;
    format_p016                 : u32 : 0x36313050;
    format_axbxgxrx106106106106 : u32 : 0x30314241;
    format_nv15                 : u32 : 0x3531564e;
    format_q410                 : u32 : 0x30313451;
    format_q401                 : u32 : 0x31303451;
    format_xrgb16161616         : u32 : 0x38345258;
    format_xbgr16161616         : u32 : 0x38344258;
    format_argb16161616         : u32 : 0x38345241;
    format_abgr16161616         : u32 : 0x38344241;

    set_user_data :: inline (self: *wl_shm, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_shm) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_shm) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *wl_shm) #c_call {
        wl_proxy.destroy(self);
    }

    create_pool :: inline (self: *wl_shm, fd: s32, size: s32) -> *wl_shm_pool #c_call {
        ret: *wl_proxy = wl_proxy.marshal_flags(
            self, WL_SHM_CREATE_POOL,
            *wl_shm_pool_interface, wl_proxy.get_version(self), 0,
            null, fd, size);
        return cast(*wl_shm_pool) ret;
    }

    add_listener :: inline (self: *wl_shm, listener: *wl_shm_listener, data: *void) -> s32 #c_call {
        return wl_proxy.add_listener(self, cast(*generic_c_call) listener, data);
    }
}

WL_SHM_CREATE_POOL       : u32 : 0;
WL_SHM_CREATE_POOL_SINCE : u32 : 1;
WL_SHM_FORMAT_SINCE      : u32 : 1;

wl_shm_listener :: struct {
    format := _stubs_.format;

    _stubs_ :: struct {
        format :: (data: *void,
            self: *wl_shm,
            format: u32) -> void #c_call {}
    }
}

wl_buffer_interface: wl_interface;
wl_buffer :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_buffer_interface;

    set_user_data :: inline (self: *wl_buffer, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_buffer) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_buffer) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *wl_buffer) #c_call {
        wl_proxy.marshal_flags(
            self, WL_BUFFER_DESTROY,
            null, wl_proxy.get_version(self), WL_MARSHAL_FLAG_DESTROY);
    }

    add_listener :: inline (self: *wl_buffer, listener: *wl_buffer_listener, data: *void) -> s32 #c_call {
        return wl_proxy.add_listener(self, cast(*generic_c_call) listener, data);
    }
}

WL_BUFFER_DESTROY       : u32 : 0;
WL_BUFFER_DESTROY_SINCE : u32 : 1;
WL_BUFFER_RELEASE_SINCE : u32 : 1;

wl_buffer_listener :: struct {
    release := _stubs_.release;

    _stubs_ :: struct {
        release :: (data: *void,
            self: *wl_buffer) -> void #c_call {}
    }
}

wl_data_offer_interface: wl_interface;
wl_data_offer :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_data_offer_interface;

    /* ENUM: wl_data_offer::error */
    error_invalid_finish      : u32 : 0;
    error_invalid_action_mask : u32 : 1;
    error_invalid_action      : u32 : 2;
    error_invalid_offer       : u32 : 3;

    set_user_data :: inline (self: *wl_data_offer, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_data_offer) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_data_offer) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    accept :: inline (self: *wl_data_offer, serial: u32, mime_type: *u8) #c_call {
        wl_proxy.marshal_flags(
            self, WL_DATA_OFFER_ACCEPT,
            null, wl_proxy.get_version(self), 0,
            serial, mime_type);
    }

    receive :: inline (self: *wl_data_offer, mime_type: *u8, fd: s32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_DATA_OFFER_RECEIVE,
            null, wl_proxy.get_version(self), 0,
            mime_type, fd);
    }

    destroy :: inline (self: *wl_data_offer) #c_call {
        wl_proxy.marshal_flags(
            self, WL_DATA_OFFER_DESTROY,
            null, wl_proxy.get_version(self), WL_MARSHAL_FLAG_DESTROY);
    }

    finish :: inline (self: *wl_data_offer) #c_call {
        wl_proxy.marshal_flags(
            self, WL_DATA_OFFER_FINISH,
            null, wl_proxy.get_version(self), 0);
    }

    set_actions :: inline (self: *wl_data_offer, dnd_actions: u32, preferred_action: u32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_DATA_OFFER_SET_ACTIONS,
            null, wl_proxy.get_version(self), 0,
            dnd_actions, preferred_action);
    }

    add_listener :: inline (self: *wl_data_offer, listener: *wl_data_offer_listener, data: *void) -> s32 #c_call {
        return wl_proxy.add_listener(self, cast(*generic_c_call) listener, data);
    }
}

WL_DATA_OFFER_ACCEPT               : u32 : 0;
WL_DATA_OFFER_RECEIVE              : u32 : 1;
WL_DATA_OFFER_DESTROY              : u32 : 2;
WL_DATA_OFFER_FINISH               : u32 : 3;
WL_DATA_OFFER_SET_ACTIONS          : u32 : 4;
WL_DATA_OFFER_ACCEPT_SINCE         : u32 : 1;
WL_DATA_OFFER_RECEIVE_SINCE        : u32 : 1;
WL_DATA_OFFER_DESTROY_SINCE        : u32 : 1;
WL_DATA_OFFER_FINISH_SINCE         : u32 : 3;
WL_DATA_OFFER_SET_ACTIONS_SINCE    : u32 : 3;
WL_DATA_OFFER_OFFER_SINCE          : u32 : 1;
WL_DATA_OFFER_SOURCE_ACTIONS_SINCE : u32 : 3;
WL_DATA_OFFER_ACTION_SINCE         : u32 : 3;

wl_data_offer_listener :: struct {
    offer          := _stubs_.offer;
    source_actions := _stubs_.source_actions;
    action         := _stubs_.action;

    _stubs_ :: struct {
        offer :: (data: *void,
            self: *wl_data_offer,
            mime_type: *u8) -> void #c_call {}
        source_actions :: (data: *void,
            self: *wl_data_offer,
            source_actions: u32) -> void #c_call {}
        action :: (data: *void,
            self: *wl_data_offer,
            dnd_action: u32) -> void #c_call {}
    }
}

wl_data_source_interface: wl_interface;
wl_data_source :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_data_source_interface;

    /* ENUM: wl_data_source::error */
    error_invalid_action_mask : u32 : 0;
    error_invalid_source      : u32 : 1;

    set_user_data :: inline (self: *wl_data_source, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_data_source) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_data_source) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    offer :: inline (self: *wl_data_source, mime_type: *u8) #c_call {
        wl_proxy.marshal_flags(
            self, WL_DATA_SOURCE_OFFER,
            null, wl_proxy.get_version(self), 0,
            mime_type);
    }

    destroy :: inline (self: *wl_data_source) #c_call {
        wl_proxy.marshal_flags(
            self, WL_DATA_SOURCE_DESTROY,
            null, wl_proxy.get_version(self), WL_MARSHAL_FLAG_DESTROY);
    }

    set_actions :: inline (self: *wl_data_source, dnd_actions: u32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_DATA_SOURCE_SET_ACTIONS,
            null, wl_proxy.get_version(self), 0,
            dnd_actions);
    }

    add_listener :: inline (self: *wl_data_source, listener: *wl_data_source_listener, data: *void) -> s32 #c_call {
        return wl_proxy.add_listener(self, cast(*generic_c_call) listener, data);
    }
}

WL_DATA_SOURCE_OFFER                    : u32 : 0;
WL_DATA_SOURCE_DESTROY                  : u32 : 1;
WL_DATA_SOURCE_SET_ACTIONS              : u32 : 2;
WL_DATA_SOURCE_OFFER_SINCE              : u32 : 1;
WL_DATA_SOURCE_DESTROY_SINCE            : u32 : 1;
WL_DATA_SOURCE_SET_ACTIONS_SINCE        : u32 : 3;
WL_DATA_SOURCE_TARGET_SINCE             : u32 : 1;
WL_DATA_SOURCE_SEND_SINCE               : u32 : 1;
WL_DATA_SOURCE_CANCELLED_SINCE          : u32 : 1;
WL_DATA_SOURCE_DND_DROP_PERFORMED_SINCE : u32 : 3;
WL_DATA_SOURCE_DND_FINISHED_SINCE       : u32 : 3;
WL_DATA_SOURCE_ACTION_SINCE             : u32 : 3;

wl_data_source_listener :: struct {
    target             := _stubs_.target;
    send               := _stubs_.send;
    cancelled          := _stubs_.cancelled;
    dnd_drop_performed := _stubs_.dnd_drop_performed;
    dnd_finished       := _stubs_.dnd_finished;
    action             := _stubs_.action;

    _stubs_ :: struct {
        target :: (data: *void,
            self: *wl_data_source,
            mime_type: *u8) -> void #c_call {}
        send :: (data: *void,
            self: *wl_data_source,
            mime_type: *u8,
            fd: s32) -> void #c_call {}
        cancelled :: (data: *void,
            self: *wl_data_source) -> void #c_call {}
        dnd_drop_performed :: (data: *void,
            self: *wl_data_source) -> void #c_call {}
        dnd_finished :: (data: *void,
            self: *wl_data_source) -> void #c_call {}
        action :: (data: *void,
            self: *wl_data_source,
            dnd_action: u32) -> void #c_call {}
    }
}

wl_data_device_interface: wl_interface;
wl_data_device :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_data_device_interface;

    /* ENUM: wl_data_device::error */
    error_role : u32 : 0;

    set_user_data :: inline (self: *wl_data_device, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_data_device) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_data_device) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *wl_data_device) #c_call {
        wl_proxy.destroy(self);
    }

    start_drag :: inline (self: *wl_data_device, source: *wl_data_source, origin: *wl_surface, icon: *wl_surface, serial: u32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_DATA_DEVICE_START_DRAG,
            null, wl_proxy.get_version(self), 0,
            source, origin, icon, serial);
    }

    set_selection :: inline (self: *wl_data_device, source: *wl_data_source, serial: u32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_DATA_DEVICE_SET_SELECTION,
            null, wl_proxy.get_version(self), 0,
            source, serial);
    }

    release :: inline (self: *wl_data_device) #c_call {
        wl_proxy.marshal_flags(
            self, WL_DATA_DEVICE_RELEASE,
            null, wl_proxy.get_version(self), WL_MARSHAL_FLAG_DESTROY);
    }

    add_listener :: inline (self: *wl_data_device, listener: *wl_data_device_listener, data: *void) -> s32 #c_call {
        return wl_proxy.add_listener(self, cast(*generic_c_call) listener, data);
    }
}

WL_DATA_DEVICE_START_DRAG          : u32 : 0;
WL_DATA_DEVICE_SET_SELECTION       : u32 : 1;
WL_DATA_DEVICE_RELEASE             : u32 : 2;
WL_DATA_DEVICE_START_DRAG_SINCE    : u32 : 1;
WL_DATA_DEVICE_SET_SELECTION_SINCE : u32 : 1;
WL_DATA_DEVICE_RELEASE_SINCE       : u32 : 2;
WL_DATA_DEVICE_DATA_OFFER_SINCE    : u32 : 1;
WL_DATA_DEVICE_ENTER_SINCE         : u32 : 1;
WL_DATA_DEVICE_LEAVE_SINCE         : u32 : 1;
WL_DATA_DEVICE_MOTION_SINCE        : u32 : 1;
WL_DATA_DEVICE_DROP_SINCE          : u32 : 1;
WL_DATA_DEVICE_SELECTION_SINCE     : u32 : 1;

wl_data_device_listener :: struct {
    data_offer := _stubs_.data_offer;
    enter      := _stubs_.enter;
    leave      := _stubs_.leave;
    motion     := _stubs_.motion;
    drop       := _stubs_.drop;
    selection  := _stubs_.selection;

    _stubs_ :: struct {
        data_offer :: (data: *void,
            self: *wl_data_device,
            id: *wl_data_offer) -> void #c_call {}
        enter :: (data: *void,
            self: *wl_data_device,
            serial: u32,
            surface: *wl_surface,
            x: wl_fixed_t,
            y: wl_fixed_t,
            id: *wl_data_offer) -> void #c_call {}
        leave :: (data: *void,
            self: *wl_data_device) -> void #c_call {}
        motion :: (data: *void,
            self: *wl_data_device,
            time: u32,
            x: wl_fixed_t,
            y: wl_fixed_t) -> void #c_call {}
        drop :: (data: *void,
            self: *wl_data_device) -> void #c_call {}
        selection :: (data: *void,
            self: *wl_data_device,
            id: *wl_data_offer) -> void #c_call {}
    }
}

wl_data_device_manager_interface: wl_interface;
wl_data_device_manager :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_data_device_manager_interface;

    /* ENUM: wl_data_device_manager::dnd_action */
    dnd_action_none : u32 : 0;
    dnd_action_copy : u32 : 1;
    dnd_action_move : u32 : 2;
    dnd_action_ask  : u32 : 4;

    set_user_data :: inline (self: *wl_data_device_manager, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_data_device_manager) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_data_device_manager) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *wl_data_device_manager) #c_call {
        wl_proxy.destroy(self);
    }

    create_data_source :: inline (self: *wl_data_device_manager) -> *wl_data_source #c_call {
        ret: *wl_proxy = wl_proxy.marshal_flags(
            self, WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE,
            *wl_data_source_interface, wl_proxy.get_version(self), 0,
            null);
        return cast(*wl_data_source) ret;
    }

    get_data_device :: inline (self: *wl_data_device_manager, seat: *wl_seat) -> *wl_data_device #c_call {
        ret: *wl_proxy = wl_proxy.marshal_flags(
            self, WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE,
            *wl_data_device_interface, wl_proxy.get_version(self), 0,
            null, seat);
        return cast(*wl_data_device) ret;
    }
}

WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE       : u32 : 0;
WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE          : u32 : 1;
WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE_SINCE : u32 : 1;
WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE_SINCE    : u32 : 1;

wl_shell_interface: wl_interface;
wl_shell :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_shell_interface;

    /* ENUM: wl_shell::error */
    error_role : u32 : 0;

    set_user_data :: inline (self: *wl_shell, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_shell) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_shell) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *wl_shell) #c_call {
        wl_proxy.destroy(self);
    }

    get_shell_surface :: inline (self: *wl_shell, surface: *wl_surface) -> *wl_shell_surface #c_call {
        ret: *wl_proxy = wl_proxy.marshal_flags(
            self, WL_SHELL_GET_SHELL_SURFACE,
            *wl_shell_surface_interface, wl_proxy.get_version(self), 0,
            null, surface);
        return cast(*wl_shell_surface) ret;
    }
}

WL_SHELL_GET_SHELL_SURFACE       : u32 : 0;
WL_SHELL_GET_SHELL_SURFACE_SINCE : u32 : 1;

wl_shell_surface_interface: wl_interface;
wl_shell_surface :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_shell_surface_interface;

    /* ENUM: wl_shell_surface::resize */
    resize_none         : u32 : 0;
    resize_top          : u32 : 1;
    resize_bottom       : u32 : 2;
    resize_left         : u32 : 4;
    resize_top_left     : u32 : 5;
    resize_bottom_left  : u32 : 6;
    resize_right        : u32 : 8;
    resize_top_right    : u32 : 9;
    resize_bottom_right : u32 : 10;

    /* ENUM: wl_shell_surface::transient */
    transient_inactive : u32 : 0x1;

    /* ENUM: wl_shell_surface::fullscreen_method */
    fullscreen_method_default : u32 : 0;
    fullscreen_method_scale   : u32 : 1;
    fullscreen_method_driver  : u32 : 2;
    fullscreen_method_fill    : u32 : 3;

    set_user_data :: inline (self: *wl_shell_surface, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_shell_surface) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_shell_surface) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *wl_shell_surface) #c_call {
        wl_proxy.destroy(self);
    }

    pong :: inline (self: *wl_shell_surface, serial: u32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SHELL_SURFACE_PONG,
            null, wl_proxy.get_version(self), 0,
            serial);
    }

    move :: inline (self: *wl_shell_surface, seat: *wl_seat, serial: u32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SHELL_SURFACE_MOVE,
            null, wl_proxy.get_version(self), 0,
            seat, serial);
    }

    resize :: inline (self: *wl_shell_surface, seat: *wl_seat, serial: u32, edges: u32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SHELL_SURFACE_RESIZE,
            null, wl_proxy.get_version(self), 0,
            seat, serial, edges);
    }

    set_toplevel :: inline (self: *wl_shell_surface) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SHELL_SURFACE_SET_TOPLEVEL,
            null, wl_proxy.get_version(self), 0);
    }

    set_transient :: inline (self: *wl_shell_surface, parent: *wl_surface, x: s32, y: s32, flags: u32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SHELL_SURFACE_SET_TRANSIENT,
            null, wl_proxy.get_version(self), 0,
            parent, x, y, flags);
    }

    set_fullscreen :: inline (self: *wl_shell_surface, method: u32, framerate: u32, output: *wl_output) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SHELL_SURFACE_SET_FULLSCREEN,
            null, wl_proxy.get_version(self), 0,
            method, framerate, output);
    }

    set_popup :: inline (self: *wl_shell_surface, seat: *wl_seat, serial: u32, parent: *wl_surface, x: s32, y: s32, flags: u32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SHELL_SURFACE_SET_POPUP,
            null, wl_proxy.get_version(self), 0,
            seat, serial, parent, x, y, flags);
    }

    set_maximized :: inline (self: *wl_shell_surface, output: *wl_output) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SHELL_SURFACE_SET_MAXIMIZED,
            null, wl_proxy.get_version(self), 0,
            output);
    }

    set_title :: inline (self: *wl_shell_surface, title: *u8) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SHELL_SURFACE_SET_TITLE,
            null, wl_proxy.get_version(self), 0,
            title);
    }

    set_class :: inline (self: *wl_shell_surface, class_: *u8) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SHELL_SURFACE_SET_CLASS,
            null, wl_proxy.get_version(self), 0,
            class_);
    }

    add_listener :: inline (self: *wl_shell_surface, listener: *wl_shell_surface_listener, data: *void) -> s32 #c_call {
        return wl_proxy.add_listener(self, cast(*generic_c_call) listener, data);
    }
}

WL_SHELL_SURFACE_PONG                 : u32 : 0;
WL_SHELL_SURFACE_MOVE                 : u32 : 1;
WL_SHELL_SURFACE_RESIZE               : u32 : 2;
WL_SHELL_SURFACE_SET_TOPLEVEL         : u32 : 3;
WL_SHELL_SURFACE_SET_TRANSIENT        : u32 : 4;
WL_SHELL_SURFACE_SET_FULLSCREEN       : u32 : 5;
WL_SHELL_SURFACE_SET_POPUP            : u32 : 6;
WL_SHELL_SURFACE_SET_MAXIMIZED        : u32 : 7;
WL_SHELL_SURFACE_SET_TITLE            : u32 : 8;
WL_SHELL_SURFACE_SET_CLASS            : u32 : 9;
WL_SHELL_SURFACE_PONG_SINCE           : u32 : 1;
WL_SHELL_SURFACE_MOVE_SINCE           : u32 : 1;
WL_SHELL_SURFACE_RESIZE_SINCE         : u32 : 1;
WL_SHELL_SURFACE_SET_TOPLEVEL_SINCE   : u32 : 1;
WL_SHELL_SURFACE_SET_TRANSIENT_SINCE  : u32 : 1;
WL_SHELL_SURFACE_SET_FULLSCREEN_SINCE : u32 : 1;
WL_SHELL_SURFACE_SET_POPUP_SINCE      : u32 : 1;
WL_SHELL_SURFACE_SET_MAXIMIZED_SINCE  : u32 : 1;
WL_SHELL_SURFACE_SET_TITLE_SINCE      : u32 : 1;
WL_SHELL_SURFACE_SET_CLASS_SINCE      : u32 : 1;
WL_SHELL_SURFACE_PING_SINCE           : u32 : 1;
WL_SHELL_SURFACE_CONFIGURE_SINCE      : u32 : 1;
WL_SHELL_SURFACE_POPUP_DONE_SINCE     : u32 : 1;

wl_shell_surface_listener :: struct {
    ping       := _stubs_.ping;
    configure  := _stubs_.configure;
    popup_done := _stubs_.popup_done;

    _stubs_ :: struct {
        ping :: (data: *void,
            self: *wl_shell_surface,
            serial: u32) -> void #c_call {}
        configure :: (data: *void,
            self: *wl_shell_surface,
            edges: u32,
            width: s32,
            height: s32) -> void #c_call {}
        popup_done :: (data: *void,
            self: *wl_shell_surface) -> void #c_call {}
    }
}

wl_surface_interface: wl_interface;
wl_surface :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_surface_interface;

    /* ENUM: wl_surface::error */
    error_invalid_scale       : u32 : 0;
    error_invalid_transform   : u32 : 1;
    error_invalid_size        : u32 : 2;
    error_invalid_offset      : u32 : 3;
    error_defunct_role_object : u32 : 4;

    set_user_data :: inline (self: *wl_surface, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_surface) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_surface) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *wl_surface) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SURFACE_DESTROY,
            null, wl_proxy.get_version(self), WL_MARSHAL_FLAG_DESTROY);
    }

    attach :: inline (self: *wl_surface, buffer: *wl_buffer, x: s32, y: s32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SURFACE_ATTACH,
            null, wl_proxy.get_version(self), 0,
            buffer, x, y);
    }

    damage :: inline (self: *wl_surface, x: s32, y: s32, width: s32, height: s32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SURFACE_DAMAGE,
            null, wl_proxy.get_version(self), 0,
            x, y, width, height);
    }

    frame :: inline (self: *wl_surface) -> *wl_callback #c_call {
        ret: *wl_proxy = wl_proxy.marshal_flags(
            self, WL_SURFACE_FRAME,
            *wl_callback_interface, wl_proxy.get_version(self), 0,
            null);
        return cast(*wl_callback) ret;
    }

    set_opaque_region :: inline (self: *wl_surface, region: *wl_region) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SURFACE_SET_OPAQUE_REGION,
            null, wl_proxy.get_version(self), 0,
            region);
    }

    set_input_region :: inline (self: *wl_surface, region: *wl_region) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SURFACE_SET_INPUT_REGION,
            null, wl_proxy.get_version(self), 0,
            region);
    }

    commit :: inline (self: *wl_surface) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SURFACE_COMMIT,
            null, wl_proxy.get_version(self), 0);
    }

    set_buffer_transform :: inline (self: *wl_surface, transform: s32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SURFACE_SET_BUFFER_TRANSFORM,
            null, wl_proxy.get_version(self), 0,
            transform);
    }

    set_buffer_scale :: inline (self: *wl_surface, scale: s32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SURFACE_SET_BUFFER_SCALE,
            null, wl_proxy.get_version(self), 0,
            scale);
    }

    damage_buffer :: inline (self: *wl_surface, x: s32, y: s32, width: s32, height: s32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SURFACE_DAMAGE_BUFFER,
            null, wl_proxy.get_version(self), 0,
            x, y, width, height);
    }

    offset :: inline (self: *wl_surface, x: s32, y: s32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SURFACE_OFFSET,
            null, wl_proxy.get_version(self), 0,
            x, y);
    }

    add_listener :: inline (self: *wl_surface, listener: *wl_surface_listener, data: *void) -> s32 #c_call {
        return wl_proxy.add_listener(self, cast(*generic_c_call) listener, data);
    }
}

WL_SURFACE_DESTROY                          : u32 : 0;
WL_SURFACE_ATTACH                           : u32 : 1;
WL_SURFACE_DAMAGE                           : u32 : 2;
WL_SURFACE_FRAME                            : u32 : 3;
WL_SURFACE_SET_OPAQUE_REGION                : u32 : 4;
WL_SURFACE_SET_INPUT_REGION                 : u32 : 5;
WL_SURFACE_COMMIT                           : u32 : 6;
WL_SURFACE_SET_BUFFER_TRANSFORM             : u32 : 7;
WL_SURFACE_SET_BUFFER_SCALE                 : u32 : 8;
WL_SURFACE_DAMAGE_BUFFER                    : u32 : 9;
WL_SURFACE_OFFSET                           : u32 : 10;
WL_SURFACE_DESTROY_SINCE                    : u32 : 1;
WL_SURFACE_ATTACH_SINCE                     : u32 : 1;
WL_SURFACE_DAMAGE_SINCE                     : u32 : 1;
WL_SURFACE_FRAME_SINCE                      : u32 : 1;
WL_SURFACE_SET_OPAQUE_REGION_SINCE          : u32 : 1;
WL_SURFACE_SET_INPUT_REGION_SINCE           : u32 : 1;
WL_SURFACE_COMMIT_SINCE                     : u32 : 1;
WL_SURFACE_SET_BUFFER_TRANSFORM_SINCE       : u32 : 2;
WL_SURFACE_SET_BUFFER_SCALE_SINCE           : u32 : 3;
WL_SURFACE_DAMAGE_BUFFER_SINCE              : u32 : 4;
WL_SURFACE_OFFSET_SINCE                     : u32 : 5;
WL_SURFACE_ENTER_SINCE                      : u32 : 1;
WL_SURFACE_LEAVE_SINCE                      : u32 : 1;
WL_SURFACE_PREFERRED_BUFFER_SCALE_SINCE     : u32 : 6;
WL_SURFACE_PREFERRED_BUFFER_TRANSFORM_SINCE : u32 : 6;

wl_surface_listener :: struct {
    enter                      := _stubs_.enter;
    leave                      := _stubs_.leave;
    preferred_buffer_scale     := _stubs_.preferred_buffer_scale;
    preferred_buffer_transform := _stubs_.preferred_buffer_transform;

    _stubs_ :: struct {
        enter :: (data: *void,
            self: *wl_surface,
            output: *wl_output) -> void #c_call {}
        leave :: (data: *void,
            self: *wl_surface,
            output: *wl_output) -> void #c_call {}
        preferred_buffer_scale :: (data: *void,
            self: *wl_surface,
            factor: s32) -> void #c_call {}
        preferred_buffer_transform :: (data: *void,
            self: *wl_surface,
            transform: u32) -> void #c_call {}
    }
}

wl_seat_interface: wl_interface;
wl_seat :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_seat_interface;

    /* ENUM: wl_seat::capability */
    capability_pointer  : u32 : 1;
    capability_keyboard : u32 : 2;
    capability_touch    : u32 : 4;

    /* ENUM: wl_seat::error */
    error_missing_capability : u32 : 0;

    set_user_data :: inline (self: *wl_seat, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_seat) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_seat) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *wl_seat) #c_call {
        wl_proxy.destroy(self);
    }

    get_pointer :: inline (self: *wl_seat) -> *wl_pointer #c_call {
        ret: *wl_proxy = wl_proxy.marshal_flags(
            self, WL_SEAT_GET_POINTER,
            *wl_pointer_interface, wl_proxy.get_version(self), 0,
            null);
        return cast(*wl_pointer) ret;
    }

    get_keyboard :: inline (self: *wl_seat) -> *wl_keyboard #c_call {
        ret: *wl_proxy = wl_proxy.marshal_flags(
            self, WL_SEAT_GET_KEYBOARD,
            *wl_keyboard_interface, wl_proxy.get_version(self), 0,
            null);
        return cast(*wl_keyboard) ret;
    }

    get_touch :: inline (self: *wl_seat) -> *wl_touch #c_call {
        ret: *wl_proxy = wl_proxy.marshal_flags(
            self, WL_SEAT_GET_TOUCH,
            *wl_touch_interface, wl_proxy.get_version(self), 0,
            null);
        return cast(*wl_touch) ret;
    }

    release :: inline (self: *wl_seat) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SEAT_RELEASE,
            null, wl_proxy.get_version(self), WL_MARSHAL_FLAG_DESTROY);
    }

    add_listener :: inline (self: *wl_seat, listener: *wl_seat_listener, data: *void) -> s32 #c_call {
        return wl_proxy.add_listener(self, cast(*generic_c_call) listener, data);
    }
}

WL_SEAT_GET_POINTER        : u32 : 0;
WL_SEAT_GET_KEYBOARD       : u32 : 1;
WL_SEAT_GET_TOUCH          : u32 : 2;
WL_SEAT_RELEASE            : u32 : 3;
WL_SEAT_GET_POINTER_SINCE  : u32 : 1;
WL_SEAT_GET_KEYBOARD_SINCE : u32 : 1;
WL_SEAT_GET_TOUCH_SINCE    : u32 : 1;
WL_SEAT_RELEASE_SINCE      : u32 : 5;
WL_SEAT_CAPABILITIES_SINCE : u32 : 1;
WL_SEAT_NAME_SINCE         : u32 : 2;

wl_seat_listener :: struct {
    capabilities := _stubs_.capabilities;
    name         := _stubs_.name;

    _stubs_ :: struct {
        capabilities :: (data: *void,
            self: *wl_seat,
            capabilities: u32) -> void #c_call {}
        name :: (data: *void,
            self: *wl_seat,
            name: *u8) -> void #c_call {}
    }
}

wl_pointer_interface: wl_interface;
wl_pointer :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_pointer_interface;

    /* ENUM: wl_pointer::error */
    error_role : u32 : 0;

    /* ENUM: wl_pointer::button_state */
    button_state_released : u32 : 0;
    button_state_pressed  : u32 : 1;

    /* ENUM: wl_pointer::axis */
    axis_vertical_scroll   : u32 : 0;
    axis_horizontal_scroll : u32 : 1;

    /* ENUM: wl_pointer::axis_source */
    axis_source_wheel      : u32 : 0;
    axis_source_finger     : u32 : 1;
    axis_source_continuous : u32 : 2;
    axis_source_wheel_tilt : u32 : 3;

    /* ENUM: wl_pointer::axis_relative_direction */
    axis_relative_direction_identical : u32 : 0;
    axis_relative_direction_inverted  : u32 : 1;

    set_user_data :: inline (self: *wl_pointer, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_pointer) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_pointer) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *wl_pointer) #c_call {
        wl_proxy.destroy(self);
    }

    set_cursor :: inline (self: *wl_pointer, serial: u32, surface: *wl_surface, hotspot_x: s32, hotspot_y: s32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_POINTER_SET_CURSOR,
            null, wl_proxy.get_version(self), 0,
            serial, surface, hotspot_x, hotspot_y);
    }

    release :: inline (self: *wl_pointer) #c_call {
        wl_proxy.marshal_flags(
            self, WL_POINTER_RELEASE,
            null, wl_proxy.get_version(self), WL_MARSHAL_FLAG_DESTROY);
    }

    add_listener :: inline (self: *wl_pointer, listener: *wl_pointer_listener, data: *void) -> s32 #c_call {
        return wl_proxy.add_listener(self, cast(*generic_c_call) listener, data);
    }
}

WL_POINTER_SET_CURSOR                    : u32 : 0;
WL_POINTER_RELEASE                       : u32 : 1;
WL_POINTER_SET_CURSOR_SINCE              : u32 : 1;
WL_POINTER_RELEASE_SINCE                 : u32 : 3;
WL_POINTER_ENTER_SINCE                   : u32 : 1;
WL_POINTER_LEAVE_SINCE                   : u32 : 1;
WL_POINTER_MOTION_SINCE                  : u32 : 1;
WL_POINTER_BUTTON_SINCE                  : u32 : 1;
WL_POINTER_AXIS_SINCE                    : u32 : 1;
WL_POINTER_FRAME_SINCE                   : u32 : 5;
WL_POINTER_AXIS_SOURCE_SINCE             : u32 : 5;
WL_POINTER_AXIS_STOP_SINCE               : u32 : 5;
WL_POINTER_AXIS_DISCRETE_SINCE           : u32 : 5;
WL_POINTER_AXIS_VALUE120_SINCE           : u32 : 8;
WL_POINTER_AXIS_RELATIVE_DIRECTION_SINCE : u32 : 9;

wl_pointer_listener :: struct {
    enter                   := _stubs_.enter;
    leave                   := _stubs_.leave;
    motion                  := _stubs_.motion;
    button                  := _stubs_.button;
    axis                    := _stubs_.axis;
    frame                   := _stubs_.frame;
    axis_source             := _stubs_.axis_source;
    axis_stop               := _stubs_.axis_stop;
    axis_discrete           := _stubs_.axis_discrete;
    axis_value120           := _stubs_.axis_value120;
    axis_relative_direction := _stubs_.axis_relative_direction;

    _stubs_ :: struct {
        enter :: (data: *void,
            self: *wl_pointer,
            serial: u32,
            surface: *wl_surface,
            surface_x: wl_fixed_t,
            surface_y: wl_fixed_t) -> void #c_call {}
        leave :: (data: *void,
            self: *wl_pointer,
            serial: u32,
            surface: *wl_surface) -> void #c_call {}
        motion :: (data: *void,
            self: *wl_pointer,
            time: u32,
            surface_x: wl_fixed_t,
            surface_y: wl_fixed_t) -> void #c_call {}
        button :: (data: *void,
            self: *wl_pointer,
            serial: u32,
            time: u32,
            button: u32,
            state: u32) -> void #c_call {}
        axis :: (data: *void,
            self: *wl_pointer,
            time: u32,
            axis: u32,
            value: wl_fixed_t) -> void #c_call {}
        frame :: (data: *void,
            self: *wl_pointer) -> void #c_call {}
        axis_source :: (data: *void,
            self: *wl_pointer,
            axis_source: u32) -> void #c_call {}
        axis_stop :: (data: *void,
            self: *wl_pointer,
            time: u32,
            axis: u32) -> void #c_call {}
        axis_discrete :: (data: *void,
            self: *wl_pointer,
            axis: u32,
            discrete: s32) -> void #c_call {}
        axis_value120 :: (data: *void,
            self: *wl_pointer,
            axis: u32,
            value120: s32) -> void #c_call {}
        axis_relative_direction :: (data: *void,
            self: *wl_pointer,
            axis: u32,
            direction: u32) -> void #c_call {}
    }
}

wl_keyboard_interface: wl_interface;
wl_keyboard :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_keyboard_interface;

    /* ENUM: wl_keyboard::keymap_format */
    keymap_format_no_keymap : u32 : 0;
    keymap_format_xkb_v1    : u32 : 1;

    /* ENUM: wl_keyboard::key_state */
    key_state_released : u32 : 0;
    key_state_pressed  : u32 : 1;

    set_user_data :: inline (self: *wl_keyboard, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_keyboard) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_keyboard) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *wl_keyboard) #c_call {
        wl_proxy.destroy(self);
    }

    release :: inline (self: *wl_keyboard) #c_call {
        wl_proxy.marshal_flags(
            self, WL_KEYBOARD_RELEASE,
            null, wl_proxy.get_version(self), WL_MARSHAL_FLAG_DESTROY);
    }

    add_listener :: inline (self: *wl_keyboard, listener: *wl_keyboard_listener, data: *void) -> s32 #c_call {
        return wl_proxy.add_listener(self, cast(*generic_c_call) listener, data);
    }
}

WL_KEYBOARD_RELEASE           : u32 : 0;
WL_KEYBOARD_RELEASE_SINCE     : u32 : 3;
WL_KEYBOARD_KEYMAP_SINCE      : u32 : 1;
WL_KEYBOARD_ENTER_SINCE       : u32 : 1;
WL_KEYBOARD_LEAVE_SINCE       : u32 : 1;
WL_KEYBOARD_KEY_SINCE         : u32 : 1;
WL_KEYBOARD_MODIFIERS_SINCE   : u32 : 1;
WL_KEYBOARD_REPEAT_INFO_SINCE : u32 : 4;

wl_keyboard_listener :: struct {
    keymap      := _stubs_.keymap;
    enter       := _stubs_.enter;
    leave       := _stubs_.leave;
    key         := _stubs_.key;
    modifiers   := _stubs_.modifiers;
    repeat_info := _stubs_.repeat_info;

    _stubs_ :: struct {
        keymap :: (data: *void,
            self: *wl_keyboard,
            format: u32,
            fd: s32,
            size: u32) -> void #c_call {}
        enter :: (data: *void,
            self: *wl_keyboard,
            serial: u32,
            surface: *wl_surface,
            keys: *wl_array) -> void #c_call {}
        leave :: (data: *void,
            self: *wl_keyboard,
            serial: u32,
            surface: *wl_surface) -> void #c_call {}
        key :: (data: *void,
            self: *wl_keyboard,
            serial: u32,
            time: u32,
            key: u32,
            state: u32) -> void #c_call {}
        modifiers :: (data: *void,
            self: *wl_keyboard,
            serial: u32,
            mods_depressed: u32,
            mods_latched: u32,
            mods_locked: u32,
            group: u32) -> void #c_call {}
        repeat_info :: (data: *void,
            self: *wl_keyboard,
            rate: s32,
            delay: s32) -> void #c_call {}
    }
}

wl_touch_interface: wl_interface;
wl_touch :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_touch_interface;

    set_user_data :: inline (self: *wl_touch, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_touch) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_touch) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *wl_touch) #c_call {
        wl_proxy.destroy(self);
    }

    release :: inline (self: *wl_touch) #c_call {
        wl_proxy.marshal_flags(
            self, WL_TOUCH_RELEASE,
            null, wl_proxy.get_version(self), WL_MARSHAL_FLAG_DESTROY);
    }

    add_listener :: inline (self: *wl_touch, listener: *wl_touch_listener, data: *void) -> s32 #c_call {
        return wl_proxy.add_listener(self, cast(*generic_c_call) listener, data);
    }
}

WL_TOUCH_RELEASE           : u32 : 0;
WL_TOUCH_RELEASE_SINCE     : u32 : 3;
WL_TOUCH_DOWN_SINCE        : u32 : 1;
WL_TOUCH_UP_SINCE          : u32 : 1;
WL_TOUCH_MOTION_SINCE      : u32 : 1;
WL_TOUCH_FRAME_SINCE       : u32 : 1;
WL_TOUCH_CANCEL_SINCE      : u32 : 1;
WL_TOUCH_SHAPE_SINCE       : u32 : 6;
WL_TOUCH_ORIENTATION_SINCE : u32 : 6;

wl_touch_listener :: struct {
    down        := _stubs_.down;
    up          := _stubs_.up;
    motion      := _stubs_.motion;
    frame       := _stubs_.frame;
    cancel      := _stubs_.cancel;
    shape       := _stubs_.shape;
    orientation := _stubs_.orientation;

    _stubs_ :: struct {
        down :: (data: *void,
            self: *wl_touch,
            serial: u32,
            time: u32,
            surface: *wl_surface,
            id: s32,
            x: wl_fixed_t,
            y: wl_fixed_t) -> void #c_call {}
        up :: (data: *void,
            self: *wl_touch,
            serial: u32,
            time: u32,
            id: s32) -> void #c_call {}
        motion :: (data: *void,
            self: *wl_touch,
            time: u32,
            id: s32,
            x: wl_fixed_t,
            y: wl_fixed_t) -> void #c_call {}
        frame :: (data: *void,
            self: *wl_touch) -> void #c_call {}
        cancel :: (data: *void,
            self: *wl_touch) -> void #c_call {}
        shape :: (data: *void,
            self: *wl_touch,
            id: s32,
            major: wl_fixed_t,
            minor: wl_fixed_t) -> void #c_call {}
        orientation :: (data: *void,
            self: *wl_touch,
            id: s32,
            orientation: wl_fixed_t) -> void #c_call {}
    }
}

wl_output_interface: wl_interface;
wl_output :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_output_interface;

    /* ENUM: wl_output::subpixel */
    subpixel_unknown        : u32 : 0;
    subpixel_none           : u32 : 1;
    subpixel_horizontal_rgb : u32 : 2;
    subpixel_horizontal_bgr : u32 : 3;
    subpixel_vertical_rgb   : u32 : 4;
    subpixel_vertical_bgr   : u32 : 5;

    /* ENUM: wl_output::transform */
    transform_normal      : u32 : 0;
    transform_90          : u32 : 1;
    transform_180         : u32 : 2;
    transform_270         : u32 : 3;
    transform_flipped     : u32 : 4;
    transform_flipped_90  : u32 : 5;
    transform_flipped_180 : u32 : 6;
    transform_flipped_270 : u32 : 7;

    /* ENUM: wl_output::mode */
    mode_current   : u32 : 0x1;
    mode_preferred : u32 : 0x2;

    set_user_data :: inline (self: *wl_output, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_output) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_output) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *wl_output) #c_call {
        wl_proxy.destroy(self);
    }

    release :: inline (self: *wl_output) #c_call {
        wl_proxy.marshal_flags(
            self, WL_OUTPUT_RELEASE,
            null, wl_proxy.get_version(self), WL_MARSHAL_FLAG_DESTROY);
    }

    add_listener :: inline (self: *wl_output, listener: *wl_output_listener, data: *void) -> s32 #c_call {
        return wl_proxy.add_listener(self, cast(*generic_c_call) listener, data);
    }
}

WL_OUTPUT_RELEASE           : u32 : 0;
WL_OUTPUT_RELEASE_SINCE     : u32 : 3;
WL_OUTPUT_GEOMETRY_SINCE    : u32 : 1;
WL_OUTPUT_MODE_SINCE        : u32 : 1;
WL_OUTPUT_DONE_SINCE        : u32 : 2;
WL_OUTPUT_SCALE_SINCE       : u32 : 2;
WL_OUTPUT_NAME_SINCE        : u32 : 4;
WL_OUTPUT_DESCRIPTION_SINCE : u32 : 4;

wl_output_listener :: struct {
    geometry    := _stubs_.geometry;
    mode        := _stubs_.mode;
    done        := _stubs_.done;
    scale       := _stubs_.scale;
    name        := _stubs_.name;
    description := _stubs_.description;

    _stubs_ :: struct {
        geometry :: (data: *void,
            self: *wl_output,
            x: s32,
            y: s32,
            physical_width: s32,
            physical_height: s32,
            subpixel: s32,
            make: *u8,
            model: *u8,
            transform: s32) -> void #c_call {}
        mode :: (data: *void,
            self: *wl_output,
            flags: u32,
            width: s32,
            height: s32,
            refresh: s32) -> void #c_call {}
        done :: (data: *void,
            self: *wl_output) -> void #c_call {}
        scale :: (data: *void,
            self: *wl_output,
            factor: s32) -> void #c_call {}
        name :: (data: *void,
            self: *wl_output,
            name: *u8) -> void #c_call {}
        description :: (data: *void,
            self: *wl_output,
            description: *u8) -> void #c_call {}
    }
}

wl_region_interface: wl_interface;
wl_region :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_region_interface;

    set_user_data :: inline (self: *wl_region, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_region) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_region) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *wl_region) #c_call {
        wl_proxy.marshal_flags(
            self, WL_REGION_DESTROY,
            null, wl_proxy.get_version(self), WL_MARSHAL_FLAG_DESTROY);
    }

    add :: inline (self: *wl_region, x: s32, y: s32, width: s32, height: s32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_REGION_ADD,
            null, wl_proxy.get_version(self), 0,
            x, y, width, height);
    }

    subtract :: inline (self: *wl_region, x: s32, y: s32, width: s32, height: s32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_REGION_SUBTRACT,
            null, wl_proxy.get_version(self), 0,
            x, y, width, height);
    }
}

WL_REGION_DESTROY        : u32 : 0;
WL_REGION_ADD            : u32 : 1;
WL_REGION_SUBTRACT       : u32 : 2;
WL_REGION_DESTROY_SINCE  : u32 : 1;
WL_REGION_ADD_SINCE      : u32 : 1;
WL_REGION_SUBTRACT_SINCE : u32 : 1;

wl_subcompositor_interface: wl_interface;
wl_subcompositor :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_subcompositor_interface;

    /* ENUM: wl_subcompositor::error */
    error_bad_surface : u32 : 0;
    error_bad_parent  : u32 : 1;

    set_user_data :: inline (self: *wl_subcompositor, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_subcompositor) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_subcompositor) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *wl_subcompositor) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SUBCOMPOSITOR_DESTROY,
            null, wl_proxy.get_version(self), WL_MARSHAL_FLAG_DESTROY);
    }

    get_subsurface :: inline (self: *wl_subcompositor, surface: *wl_surface, parent: *wl_surface) -> *wl_subsurface #c_call {
        ret: *wl_proxy = wl_proxy.marshal_flags(
            self, WL_SUBCOMPOSITOR_GET_SUBSURFACE,
            *wl_subsurface_interface, wl_proxy.get_version(self), 0,
            null, surface, parent);
        return cast(*wl_subsurface) ret;
    }
}

WL_SUBCOMPOSITOR_DESTROY              : u32 : 0;
WL_SUBCOMPOSITOR_GET_SUBSURFACE       : u32 : 1;
WL_SUBCOMPOSITOR_DESTROY_SINCE        : u32 : 1;
WL_SUBCOMPOSITOR_GET_SUBSURFACE_SINCE : u32 : 1;

wl_subsurface_interface: wl_interface;
wl_subsurface :: struct {
    #as _proxy: wl_proxy;
    _interface_ :: *wl_subsurface_interface;

    /* ENUM: wl_subsurface::error */
    error_bad_surface : u32 : 0;

    set_user_data :: inline (self: *wl_subsurface, user_data: *void) #c_call {
        wl_proxy.set_user_data(self, user_data);
    }

    get_user_data :: inline (self: *wl_subsurface) -> *void #c_call {
        return wl_proxy.get_user_data(self);
    }

    get_version :: inline (self: *wl_subsurface) -> u32 #c_call {
        return wl_proxy.get_version(self);
    }

    destroy :: inline (self: *wl_subsurface) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SUBSURFACE_DESTROY,
            null, wl_proxy.get_version(self), WL_MARSHAL_FLAG_DESTROY);
    }

    set_position :: inline (self: *wl_subsurface, x: s32, y: s32) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SUBSURFACE_SET_POSITION,
            null, wl_proxy.get_version(self), 0,
            x, y);
    }

    place_above :: inline (self: *wl_subsurface, sibling: *wl_surface) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SUBSURFACE_PLACE_ABOVE,
            null, wl_proxy.get_version(self), 0,
            sibling);
    }

    place_below :: inline (self: *wl_subsurface, sibling: *wl_surface) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SUBSURFACE_PLACE_BELOW,
            null, wl_proxy.get_version(self), 0,
            sibling);
    }

    set_sync :: inline (self: *wl_subsurface) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SUBSURFACE_SET_SYNC,
            null, wl_proxy.get_version(self), 0);
    }

    set_desync :: inline (self: *wl_subsurface) #c_call {
        wl_proxy.marshal_flags(
            self, WL_SUBSURFACE_SET_DESYNC,
            null, wl_proxy.get_version(self), 0);
    }
}

WL_SUBSURFACE_DESTROY            : u32 : 0;
WL_SUBSURFACE_SET_POSITION       : u32 : 1;
WL_SUBSURFACE_PLACE_ABOVE        : u32 : 2;
WL_SUBSURFACE_PLACE_BELOW        : u32 : 3;
WL_SUBSURFACE_SET_SYNC           : u32 : 4;
WL_SUBSURFACE_SET_DESYNC         : u32 : 5;
WL_SUBSURFACE_DESTROY_SINCE      : u32 : 1;
WL_SUBSURFACE_SET_POSITION_SINCE : u32 : 1;
WL_SUBSURFACE_PLACE_ABOVE_SINCE  : u32 : 1;
WL_SUBSURFACE_PLACE_BELOW_SINCE  : u32 : 1;
WL_SUBSURFACE_SET_SYNC_SINCE     : u32 : 1;
WL_SUBSURFACE_SET_DESYNC_SINCE   : u32 : 1;


#scope_module
wayland_protocol_init :: () {
    wayland_types_storage = .[
        /* __DUMMY__ */
        null,  // 0
        /* REQUEST: wl_display::sync */
        *wl_callback_interface,   // 1
        /* REQUEST: wl_display::get_registry */
        *wl_registry_interface,   // 2
        /* EVENT: wl_display::error */
        null,  // 3
        null,  // 4
        null,  // 5
        /* EVENT: wl_display::delete_id */
        null,  // 6
        /* REQUEST: wl_registry::bind */
        null,  // 7
        null,  // 8
        /* EVENT: wl_registry::global */
        null,  // 9
        null,  // 10
        null,  // 11
        /* EVENT: wl_registry::global_remove */
        null,  // 12
        /* EVENT: wl_callback::done */
        null,  // 13
        /* REQUEST: wl_compositor::create_surface */
        *wl_surface_interface,   // 14
        /* REQUEST: wl_compositor::create_region */
        *wl_region_interface,   // 15
        /* REQUEST: wl_shm_pool::create_buffer */
        *wl_buffer_interface,   // 16
        null,  // 17
        null,  // 18
        null,  // 19
        null,  // 20
        null,  // 21
        /* REQUEST: wl_shm_pool::resize */
        null,  // 22
        /* REQUEST: wl_shm::create_pool */
        *wl_shm_pool_interface,   // 23
        null,  // 24
        null,  // 25
        /* EVENT: wl_shm::format */
        null,  // 26
        /* REQUEST: wl_data_offer::accept */
        null,  // 27
        null,  // 28
        /* REQUEST: wl_data_offer::receive */
        null,  // 29
        null,  // 30
        /* REQUEST: wl_data_offer::set_actions */
        null,  // 31
        null,  // 32
        /* EVENT: wl_data_offer::offer */
        null,  // 33
        /* EVENT: wl_data_offer::source_actions */
        null,  // 34
        /* EVENT: wl_data_offer::action */
        null,  // 35
        /* REQUEST: wl_data_source::offer */
        null,  // 36
        /* REQUEST: wl_data_source::set_actions */
        null,  // 37
        /* EVENT: wl_data_source::target */
        null,  // 38
        /* EVENT: wl_data_source::send */
        null,  // 39
        null,  // 40
        /* EVENT: wl_data_source::action */
        null,  // 41
        /* REQUEST: wl_data_device::start_drag */
        *wl_data_source_interface,   // 42
        *wl_surface_interface,   // 43
        *wl_surface_interface,   // 44
        null,  // 45
        /* REQUEST: wl_data_device::set_selection */
        *wl_data_source_interface,   // 46
        null,  // 47
        /* EVENT: wl_data_device::data_offer */
        *wl_data_offer_interface,  // 48
        /* EVENT: wl_data_device::enter */
        null,  // 49
        *wl_surface_interface,  // 50
        null,  // 51
        null,  // 52
        *wl_data_offer_interface,  // 53
        /* EVENT: wl_data_device::motion */
        null,  // 54
        null,  // 55
        null,  // 56
        /* EVENT: wl_data_device::selection */
        *wl_data_offer_interface,  // 57
        /* REQUEST: wl_data_device_manager::create_data_source */
        *wl_data_source_interface,   // 58
        /* REQUEST: wl_data_device_manager::get_data_device */
        *wl_data_device_interface,   // 59
        *wl_seat_interface,   // 60
        /* REQUEST: wl_shell::get_shell_surface */
        *wl_shell_surface_interface,   // 61
        *wl_surface_interface,   // 62
        /* REQUEST: wl_shell_surface::pong */
        null,  // 63
        /* REQUEST: wl_shell_surface::move */
        *wl_seat_interface,   // 64
        null,  // 65
        /* REQUEST: wl_shell_surface::resize */
        *wl_seat_interface,   // 66
        null,  // 67
        null,  // 68
        /* REQUEST: wl_shell_surface::set_transient */
        *wl_surface_interface,   // 69
        null,  // 70
        null,  // 71
        null,  // 72
        /* REQUEST: wl_shell_surface::set_fullscreen */
        null,  // 73
        null,  // 74
        *wl_output_interface,   // 75
        /* REQUEST: wl_shell_surface::set_popup */
        *wl_seat_interface,   // 76
        null,  // 77
        *wl_surface_interface,   // 78
        null,  // 79
        null,  // 80
        null,  // 81
        /* REQUEST: wl_shell_surface::set_maximized */
        *wl_output_interface,   // 82
        /* REQUEST: wl_shell_surface::set_title */
        null,  // 83
        /* REQUEST: wl_shell_surface::set_class */
        null,  // 84
        /* EVENT: wl_shell_surface::ping */
        null,  // 85
        /* EVENT: wl_shell_surface::configure */
        null,  // 86
        null,  // 87
        null,  // 88
        /* REQUEST: wl_surface::attach */
        *wl_buffer_interface,   // 89
        null,  // 90
        null,  // 91
        /* REQUEST: wl_surface::damage */
        null,  // 92
        null,  // 93
        null,  // 94
        null,  // 95
        /* REQUEST: wl_surface::frame */
        *wl_callback_interface,   // 96
        /* REQUEST: wl_surface::set_opaque_region */
        *wl_region_interface,   // 97
        /* REQUEST: wl_surface::set_input_region */
        *wl_region_interface,   // 98
        /* REQUEST: wl_surface::set_buffer_transform */
        null,  // 99
        /* REQUEST: wl_surface::set_buffer_scale */
        null,  // 100
        /* REQUEST: wl_surface::damage_buffer */
        null,  // 101
        null,  // 102
        null,  // 103
        null,  // 104
        /* REQUEST: wl_surface::offset */
        null,  // 105
        null,  // 106
        /* EVENT: wl_surface::enter */
        *wl_output_interface,  // 107
        /* EVENT: wl_surface::leave */
        *wl_output_interface,  // 108
        /* EVENT: wl_surface::preferred_buffer_scale */
        null,  // 109
        /* EVENT: wl_surface::preferred_buffer_transform */
        null,  // 110
        /* REQUEST: wl_seat::get_pointer */
        *wl_pointer_interface,   // 111
        /* REQUEST: wl_seat::get_keyboard */
        *wl_keyboard_interface,   // 112
        /* REQUEST: wl_seat::get_touch */
        *wl_touch_interface,   // 113
        /* EVENT: wl_seat::capabilities */
        null,  // 114
        /* EVENT: wl_seat::name */
        null,  // 115
        /* REQUEST: wl_pointer::set_cursor */
        null,  // 116
        *wl_surface_interface,   // 117
        null,  // 118
        null,  // 119
        /* EVENT: wl_pointer::enter */
        null,  // 120
        *wl_surface_interface,  // 121
        null,  // 122
        null,  // 123
        /* EVENT: wl_pointer::leave */
        null,  // 124
        *wl_surface_interface,  // 125
        /* EVENT: wl_pointer::motion */
        null,  // 126
        null,  // 127
        null,  // 128
        /* EVENT: wl_pointer::button */
        null,  // 129
        null,  // 130
        null,  // 131
        null,  // 132
        /* EVENT: wl_pointer::axis */
        null,  // 133
        null,  // 134
        null,  // 135
        /* EVENT: wl_pointer::axis_source */
        null,  // 136
        /* EVENT: wl_pointer::axis_stop */
        null,  // 137
        null,  // 138
        /* EVENT: wl_pointer::axis_discrete */
        null,  // 139
        null,  // 140
        /* EVENT: wl_pointer::axis_value120 */
        null,  // 141
        null,  // 142
        /* EVENT: wl_pointer::axis_relative_direction */
        null,  // 143
        null,  // 144
        /* EVENT: wl_keyboard::keymap */
        null,  // 145
        null,  // 146
        null,  // 147
        /* EVENT: wl_keyboard::enter */
        null,  // 148
        *wl_surface_interface,  // 149
        null,  // 150
        /* EVENT: wl_keyboard::leave */
        null,  // 151
        *wl_surface_interface,  // 152
        /* EVENT: wl_keyboard::key */
        null,  // 153
        null,  // 154
        null,  // 155
        null,  // 156
        /* EVENT: wl_keyboard::modifiers */
        null,  // 157
        null,  // 158
        null,  // 159
        null,  // 160
        null,  // 161
        /* EVENT: wl_keyboard::repeat_info */
        null,  // 162
        null,  // 163
        /* EVENT: wl_touch::down */
        null,  // 164
        null,  // 165
        *wl_surface_interface,  // 166
        null,  // 167
        null,  // 168
        null,  // 169
        /* EVENT: wl_touch::up */
        null,  // 170
        null,  // 171
        null,  // 172
        /* EVENT: wl_touch::motion */
        null,  // 173
        null,  // 174
        null,  // 175
        null,  // 176
        /* EVENT: wl_touch::shape */
        null,  // 177
        null,  // 178
        null,  // 179
        /* EVENT: wl_touch::orientation */
        null,  // 180
        null,  // 181
        /* EVENT: wl_output::geometry */
        null,  // 182
        null,  // 183
        null,  // 184
        null,  // 185
        null,  // 186
        null,  // 187
        null,  // 188
        null,  // 189
        /* EVENT: wl_output::mode */
        null,  // 190
        null,  // 191
        null,  // 192
        null,  // 193
        /* EVENT: wl_output::scale */
        null,  // 194
        /* EVENT: wl_output::name */
        null,  // 195
        /* EVENT: wl_output::description */
        null,  // 196
        /* REQUEST: wl_region::add */
        null,  // 197
        null,  // 198
        null,  // 199
        null,  // 200
        /* REQUEST: wl_region::subtract */
        null,  // 201
        null,  // 202
        null,  // 203
        null,  // 204
        /* REQUEST: wl_subcompositor::get_subsurface */
        *wl_subsurface_interface,   // 205
        *wl_surface_interface,   // 206
        *wl_surface_interface,   // 207
        /* REQUEST: wl_subsurface::set_position */
        null,  // 208
        null,  // 209
        /* REQUEST: wl_subsurface::place_above */
        *wl_surface_interface,   // 210
        /* REQUEST: wl_subsurface::place_below */
        *wl_surface_interface,   // 211
    ];

    wl_display_requests[0] = .{"sync", "n", wayland_types_storage.data + 1};
    wl_display_requests[1] = .{"get_registry", "n", wayland_types_storage.data + 2};
    wl_display_events[0] = .{"error", "ous", wayland_types_storage.data + 3};
    wl_display_events[1] = .{"delete_id", "u", wayland_types_storage.data + 6};
    wl_display_interface = .{
        "wl_display", 1,
        wl_display_requests.count, wl_display_requests.data,
        wl_display_events.count, wl_display_events.data,
    };

    wl_registry_requests[0] = .{"bind", "usun", wayland_types_storage.data + 7};
    wl_registry_events[0] = .{"global", "usu", wayland_types_storage.data + 9};
    wl_registry_events[1] = .{"global_remove", "u", wayland_types_storage.data + 12};
    wl_registry_interface = .{
        "wl_registry", 1,
        wl_registry_requests.count, wl_registry_requests.data,
        wl_registry_events.count, wl_registry_events.data,
    };

    wl_callback_events[0] = .{"done", "u", wayland_types_storage.data + 13};
    wl_callback_interface = .{
        "wl_callback", 1,
        0, null,
        wl_callback_events.count, wl_callback_events.data,
    };

    wl_compositor_requests[0] = .{"create_surface", "n", wayland_types_storage.data + 14};
    wl_compositor_requests[1] = .{"create_region", "n", wayland_types_storage.data + 15};
    wl_compositor_interface = .{
        "wl_compositor", 6,
        wl_compositor_requests.count, wl_compositor_requests.data,
        0, null,
    };

    wl_shm_pool_requests[0] = .{"create_buffer", "niiiiu", wayland_types_storage.data + 16};
    wl_shm_pool_requests[1] = .{"destroy", "", wayland_types_storage.data + 0};
    wl_shm_pool_requests[2] = .{"resize", "i", wayland_types_storage.data + 22};
    wl_shm_pool_interface = .{
        "wl_shm_pool", 1,
        wl_shm_pool_requests.count, wl_shm_pool_requests.data,
        0, null,
    };

    wl_shm_requests[0] = .{"create_pool", "nhi", wayland_types_storage.data + 23};
    wl_shm_events[0] = .{"format", "u", wayland_types_storage.data + 26};
    wl_shm_interface = .{
        "wl_shm", 1,
        wl_shm_requests.count, wl_shm_requests.data,
        wl_shm_events.count, wl_shm_events.data,
    };

    wl_buffer_requests[0] = .{"destroy", "", wayland_types_storage.data + 0};
    wl_buffer_events[0] = .{"release", "", wayland_types_storage.data + 0};
    wl_buffer_interface = .{
        "wl_buffer", 1,
        wl_buffer_requests.count, wl_buffer_requests.data,
        wl_buffer_events.count, wl_buffer_events.data,
    };

    wl_data_offer_requests[0] = .{"accept", "u?s", wayland_types_storage.data + 27};
    wl_data_offer_requests[1] = .{"receive", "sh", wayland_types_storage.data + 29};
    wl_data_offer_requests[2] = .{"destroy", "", wayland_types_storage.data + 0};
    wl_data_offer_requests[3] = .{"finish", "", wayland_types_storage.data + 0};
    wl_data_offer_requests[4] = .{"set_actions", "uu", wayland_types_storage.data + 31};
    wl_data_offer_events[0] = .{"offer", "s", wayland_types_storage.data + 33};
    wl_data_offer_events[1] = .{"source_actions", "u", wayland_types_storage.data + 34};
    wl_data_offer_events[2] = .{"action", "u", wayland_types_storage.data + 35};
    wl_data_offer_interface = .{
        "wl_data_offer", 3,
        wl_data_offer_requests.count, wl_data_offer_requests.data,
        wl_data_offer_events.count, wl_data_offer_events.data,
    };

    wl_data_source_requests[0] = .{"offer", "s", wayland_types_storage.data + 36};
    wl_data_source_requests[1] = .{"destroy", "", wayland_types_storage.data + 0};
    wl_data_source_requests[2] = .{"set_actions", "u", wayland_types_storage.data + 37};
    wl_data_source_events[0] = .{"target", "?s", wayland_types_storage.data + 38};
    wl_data_source_events[1] = .{"send", "sh", wayland_types_storage.data + 39};
    wl_data_source_events[2] = .{"cancelled", "", wayland_types_storage.data + 0};
    wl_data_source_events[3] = .{"dnd_drop_performed", "", wayland_types_storage.data + 0};
    wl_data_source_events[4] = .{"dnd_finished", "", wayland_types_storage.data + 0};
    wl_data_source_events[5] = .{"action", "u", wayland_types_storage.data + 41};
    wl_data_source_interface = .{
        "wl_data_source", 3,
        wl_data_source_requests.count, wl_data_source_requests.data,
        wl_data_source_events.count, wl_data_source_events.data,
    };

    wl_data_device_requests[0] = .{"start_drag", "?oo?ou", wayland_types_storage.data + 42};
    wl_data_device_requests[1] = .{"set_selection", "?ou", wayland_types_storage.data + 46};
    wl_data_device_requests[2] = .{"release", "", wayland_types_storage.data + 0};
    wl_data_device_events[0] = .{"data_offer", "n", wayland_types_storage.data + 48};
    wl_data_device_events[1] = .{"enter", "uoff?o", wayland_types_storage.data + 49};
    wl_data_device_events[2] = .{"leave", "", wayland_types_storage.data + 0};
    wl_data_device_events[3] = .{"motion", "uff", wayland_types_storage.data + 54};
    wl_data_device_events[4] = .{"drop", "", wayland_types_storage.data + 0};
    wl_data_device_events[5] = .{"selection", "?o", wayland_types_storage.data + 57};
    wl_data_device_interface = .{
        "wl_data_device", 3,
        wl_data_device_requests.count, wl_data_device_requests.data,
        wl_data_device_events.count, wl_data_device_events.data,
    };

    wl_data_device_manager_requests[0] = .{"create_data_source", "n", wayland_types_storage.data + 58};
    wl_data_device_manager_requests[1] = .{"get_data_device", "no", wayland_types_storage.data + 59};
    wl_data_device_manager_interface = .{
        "wl_data_device_manager", 3,
        wl_data_device_manager_requests.count, wl_data_device_manager_requests.data,
        0, null,
    };

    wl_shell_requests[0] = .{"get_shell_surface", "no", wayland_types_storage.data + 61};
    wl_shell_interface = .{
        "wl_shell", 1,
        wl_shell_requests.count, wl_shell_requests.data,
        0, null,
    };

    wl_shell_surface_requests[0] = .{"pong", "u", wayland_types_storage.data + 63};
    wl_shell_surface_requests[1] = .{"move", "ou", wayland_types_storage.data + 64};
    wl_shell_surface_requests[2] = .{"resize", "ouu", wayland_types_storage.data + 66};
    wl_shell_surface_requests[3] = .{"set_toplevel", "", wayland_types_storage.data + 0};
    wl_shell_surface_requests[4] = .{"set_transient", "oiiu", wayland_types_storage.data + 69};
    wl_shell_surface_requests[5] = .{"set_fullscreen", "uu?o", wayland_types_storage.data + 73};
    wl_shell_surface_requests[6] = .{"set_popup", "ouoiiu", wayland_types_storage.data + 76};
    wl_shell_surface_requests[7] = .{"set_maximized", "?o", wayland_types_storage.data + 82};
    wl_shell_surface_requests[8] = .{"set_title", "s", wayland_types_storage.data + 83};
    wl_shell_surface_requests[9] = .{"set_class", "s", wayland_types_storage.data + 84};
    wl_shell_surface_events[0] = .{"ping", "u", wayland_types_storage.data + 85};
    wl_shell_surface_events[1] = .{"configure", "uii", wayland_types_storage.data + 86};
    wl_shell_surface_events[2] = .{"popup_done", "", wayland_types_storage.data + 0};
    wl_shell_surface_interface = .{
        "wl_shell_surface", 1,
        wl_shell_surface_requests.count, wl_shell_surface_requests.data,
        wl_shell_surface_events.count, wl_shell_surface_events.data,
    };

    wl_surface_requests[0] = .{"destroy", "", wayland_types_storage.data + 0};
    wl_surface_requests[1] = .{"attach", "?oii", wayland_types_storage.data + 89};
    wl_surface_requests[2] = .{"damage", "iiii", wayland_types_storage.data + 92};
    wl_surface_requests[3] = .{"frame", "n", wayland_types_storage.data + 96};
    wl_surface_requests[4] = .{"set_opaque_region", "?o", wayland_types_storage.data + 97};
    wl_surface_requests[5] = .{"set_input_region", "?o", wayland_types_storage.data + 98};
    wl_surface_requests[6] = .{"commit", "", wayland_types_storage.data + 0};
    wl_surface_requests[7] = .{"set_buffer_transform", "i", wayland_types_storage.data + 99};
    wl_surface_requests[8] = .{"set_buffer_scale", "i", wayland_types_storage.data + 100};
    wl_surface_requests[9] = .{"damage_buffer", "iiii", wayland_types_storage.data + 101};
    wl_surface_requests[10] = .{"offset", "ii", wayland_types_storage.data + 105};
    wl_surface_events[0] = .{"enter", "o", wayland_types_storage.data + 107};
    wl_surface_events[1] = .{"leave", "o", wayland_types_storage.data + 108};
    wl_surface_events[2] = .{"preferred_buffer_scale", "i", wayland_types_storage.data + 109};
    wl_surface_events[3] = .{"preferred_buffer_transform", "u", wayland_types_storage.data + 110};
    wl_surface_interface = .{
        "wl_surface", 6,
        wl_surface_requests.count, wl_surface_requests.data,
        wl_surface_events.count, wl_surface_events.data,
    };

    wl_seat_requests[0] = .{"get_pointer", "n", wayland_types_storage.data + 111};
    wl_seat_requests[1] = .{"get_keyboard", "n", wayland_types_storage.data + 112};
    wl_seat_requests[2] = .{"get_touch", "n", wayland_types_storage.data + 113};
    wl_seat_requests[3] = .{"release", "", wayland_types_storage.data + 0};
    wl_seat_events[0] = .{"capabilities", "u", wayland_types_storage.data + 114};
    wl_seat_events[1] = .{"name", "s", wayland_types_storage.data + 115};
    wl_seat_interface = .{
        "wl_seat", 9,
        wl_seat_requests.count, wl_seat_requests.data,
        wl_seat_events.count, wl_seat_events.data,
    };

    wl_pointer_requests[0] = .{"set_cursor", "u?oii", wayland_types_storage.data + 116};
    wl_pointer_requests[1] = .{"release", "", wayland_types_storage.data + 0};
    wl_pointer_events[0] = .{"enter", "uoff", wayland_types_storage.data + 120};
    wl_pointer_events[1] = .{"leave", "uo", wayland_types_storage.data + 124};
    wl_pointer_events[2] = .{"motion", "uff", wayland_types_storage.data + 126};
    wl_pointer_events[3] = .{"button", "uuuu", wayland_types_storage.data + 129};
    wl_pointer_events[4] = .{"axis", "uuf", wayland_types_storage.data + 133};
    wl_pointer_events[5] = .{"frame", "", wayland_types_storage.data + 0};
    wl_pointer_events[6] = .{"axis_source", "u", wayland_types_storage.data + 136};
    wl_pointer_events[7] = .{"axis_stop", "uu", wayland_types_storage.data + 137};
    wl_pointer_events[8] = .{"axis_discrete", "ui", wayland_types_storage.data + 139};
    wl_pointer_events[9] = .{"axis_value120", "ui", wayland_types_storage.data + 141};
    wl_pointer_events[10] = .{"axis_relative_direction", "uu", wayland_types_storage.data + 143};
    wl_pointer_interface = .{
        "wl_pointer", 9,
        wl_pointer_requests.count, wl_pointer_requests.data,
        wl_pointer_events.count, wl_pointer_events.data,
    };

    wl_keyboard_requests[0] = .{"release", "", wayland_types_storage.data + 0};
    wl_keyboard_events[0] = .{"keymap", "uhu", wayland_types_storage.data + 145};
    wl_keyboard_events[1] = .{"enter", "uoa", wayland_types_storage.data + 148};
    wl_keyboard_events[2] = .{"leave", "uo", wayland_types_storage.data + 151};
    wl_keyboard_events[3] = .{"key", "uuuu", wayland_types_storage.data + 153};
    wl_keyboard_events[4] = .{"modifiers", "uuuuu", wayland_types_storage.data + 157};
    wl_keyboard_events[5] = .{"repeat_info", "ii", wayland_types_storage.data + 162};
    wl_keyboard_interface = .{
        "wl_keyboard", 9,
        wl_keyboard_requests.count, wl_keyboard_requests.data,
        wl_keyboard_events.count, wl_keyboard_events.data,
    };

    wl_touch_requests[0] = .{"release", "", wayland_types_storage.data + 0};
    wl_touch_events[0] = .{"down", "uuoiff", wayland_types_storage.data + 164};
    wl_touch_events[1] = .{"up", "uui", wayland_types_storage.data + 170};
    wl_touch_events[2] = .{"motion", "uiff", wayland_types_storage.data + 173};
    wl_touch_events[3] = .{"frame", "", wayland_types_storage.data + 0};
    wl_touch_events[4] = .{"cancel", "", wayland_types_storage.data + 0};
    wl_touch_events[5] = .{"shape", "iff", wayland_types_storage.data + 177};
    wl_touch_events[6] = .{"orientation", "if", wayland_types_storage.data + 180};
    wl_touch_interface = .{
        "wl_touch", 9,
        wl_touch_requests.count, wl_touch_requests.data,
        wl_touch_events.count, wl_touch_events.data,
    };

    wl_output_requests[0] = .{"release", "", wayland_types_storage.data + 0};
    wl_output_events[0] = .{"geometry", "iiiiissi", wayland_types_storage.data + 182};
    wl_output_events[1] = .{"mode", "uiii", wayland_types_storage.data + 190};
    wl_output_events[2] = .{"done", "", wayland_types_storage.data + 0};
    wl_output_events[3] = .{"scale", "i", wayland_types_storage.data + 194};
    wl_output_events[4] = .{"name", "s", wayland_types_storage.data + 195};
    wl_output_events[5] = .{"description", "s", wayland_types_storage.data + 196};
    wl_output_interface = .{
        "wl_output", 4,
        wl_output_requests.count, wl_output_requests.data,
        wl_output_events.count, wl_output_events.data,
    };

    wl_region_requests[0] = .{"destroy", "", wayland_types_storage.data + 0};
    wl_region_requests[1] = .{"add", "iiii", wayland_types_storage.data + 197};
    wl_region_requests[2] = .{"subtract", "iiii", wayland_types_storage.data + 201};
    wl_region_interface = .{
        "wl_region", 1,
        wl_region_requests.count, wl_region_requests.data,
        0, null,
    };

    wl_subcompositor_requests[0] = .{"destroy", "", wayland_types_storage.data + 0};
    wl_subcompositor_requests[1] = .{"get_subsurface", "noo", wayland_types_storage.data + 205};
    wl_subcompositor_interface = .{
        "wl_subcompositor", 1,
        wl_subcompositor_requests.count, wl_subcompositor_requests.data,
        0, null,
    };

    wl_subsurface_requests[0] = .{"destroy", "", wayland_types_storage.data + 0};
    wl_subsurface_requests[1] = .{"set_position", "ii", wayland_types_storage.data + 208};
    wl_subsurface_requests[2] = .{"place_above", "o", wayland_types_storage.data + 210};
    wl_subsurface_requests[3] = .{"place_below", "o", wayland_types_storage.data + 211};
    wl_subsurface_requests[4] = .{"set_sync", "", wayland_types_storage.data + 0};
    wl_subsurface_requests[5] = .{"set_desync", "", wayland_types_storage.data + 0};
    wl_subsurface_interface = .{
        "wl_subsurface", 1,
        wl_subsurface_requests.count, wl_subsurface_requests.data,
        0, null,
    };
}

wl_display_connect                :: (name: *u8) -> *wl_display #foreign libwayland_client;
wl_display_connect_to_fd          :: (fd: s32) -> *wl_display #foreign libwayland_client;
wl_display_disconnect             :: (display: *wl_display) -> void #foreign libwayland_client;
wl_display_get_fd                 :: (display: *wl_display) -> s32 #foreign libwayland_client;
wl_display_dispatch               :: (display: *wl_display) -> s32 #foreign libwayland_client;
wl_display_dispatch_queue         :: (display: *wl_display, queue: wl_event_queue) -> s32 #foreign libwayland_client;
wl_display_dispatch_queue_pending :: (display: *wl_display, queue: wl_event_queue) -> s32 #foreign libwayland_client;
wl_display_dispatch_pending       :: (display: *wl_display) -> s32 #foreign libwayland_client;
wl_display_get_error              :: (display: *wl_display) -> s32 #foreign libwayland_client;
wl_display_get_protocol_error     :: (display: *wl_display, intf: **wl_interface, id: *u32) -> u32 #foreign libwayland_client;
wl_display_flush                  :: (display: *wl_display) -> s32 #foreign libwayland_client;
wl_display_roundtrip_queue        :: (display: *wl_display, queue: *wl_event_queue) -> s32 #foreign libwayland_client;
wl_display_roundtrip              :: (display: *wl_display) -> s32 #foreign libwayland_client;
wl_display_create_queue           :: (display: *wl_display) -> *wl_event_queue #foreign libwayland_client;
wl_display_prepare_read_queue     :: (display: *wl_display, queue: *wl_event_queue) -> s32 #foreign libwayland_client;
wl_display_prepare_read           :: (display: *wl_display) -> s32 #foreign libwayland_client;
wl_display_cancel_read            :: (display: *wl_display) -> void #foreign libwayland_client;
wl_display_read_events            :: (display: *wl_display) -> s32 #foreign libwayland_client;


#scope_file
wayland_types_storage: []*wl_interface;

wl_display_requests: [2]wl_message;
wl_display_events  : [2]wl_message;

wl_registry_requests: [1]wl_message;
wl_registry_events  : [2]wl_message;

wl_callback_events  : [1]wl_message;

wl_compositor_requests: [2]wl_message;

wl_shm_pool_requests: [3]wl_message;

wl_shm_requests: [1]wl_message;
wl_shm_events  : [1]wl_message;

wl_buffer_requests: [1]wl_message;
wl_buffer_events  : [1]wl_message;

wl_data_offer_requests: [5]wl_message;
wl_data_offer_events  : [3]wl_message;

wl_data_source_requests: [3]wl_message;
wl_data_source_events  : [6]wl_message;

wl_data_device_requests: [3]wl_message;
wl_data_device_events  : [6]wl_message;

wl_data_device_manager_requests: [2]wl_message;

wl_shell_requests: [1]wl_message;

wl_shell_surface_requests: [10]wl_message;
wl_shell_surface_events  : [3]wl_message;

wl_surface_requests: [11]wl_message;
wl_surface_events  : [4]wl_message;

wl_seat_requests: [4]wl_message;
wl_seat_events  : [2]wl_message;

wl_pointer_requests: [2]wl_message;
wl_pointer_events  : [11]wl_message;

wl_keyboard_requests: [1]wl_message;
wl_keyboard_events  : [6]wl_message;

wl_touch_requests: [1]wl_message;
wl_touch_events  : [7]wl_message;

wl_output_requests: [1]wl_message;
wl_output_events  : [6]wl_message;

wl_region_requests: [3]wl_message;

wl_subcompositor_requests: [2]wl_message;

wl_subsurface_requests: [6]wl_message;

#assert size_of(wl_display) == 0 "wayland-scanner bug: wl_display is non-empty";
#assert size_of(wl_registry) == 0 "wayland-scanner bug: wl_registry is non-empty";
#assert size_of(wl_callback) == 0 "wayland-scanner bug: wl_callback is non-empty";
#assert size_of(wl_compositor) == 0 "wayland-scanner bug: wl_compositor is non-empty";
#assert size_of(wl_shm_pool) == 0 "wayland-scanner bug: wl_shm_pool is non-empty";
#assert size_of(wl_shm) == 0 "wayland-scanner bug: wl_shm is non-empty";
#assert size_of(wl_buffer) == 0 "wayland-scanner bug: wl_buffer is non-empty";
#assert size_of(wl_data_offer) == 0 "wayland-scanner bug: wl_data_offer is non-empty";
#assert size_of(wl_data_source) == 0 "wayland-scanner bug: wl_data_source is non-empty";
#assert size_of(wl_data_device) == 0 "wayland-scanner bug: wl_data_device is non-empty";
#assert size_of(wl_data_device_manager) == 0 "wayland-scanner bug: wl_data_device_manager is non-empty";
#assert size_of(wl_shell) == 0 "wayland-scanner bug: wl_shell is non-empty";
#assert size_of(wl_shell_surface) == 0 "wayland-scanner bug: wl_shell_surface is non-empty";
#assert size_of(wl_surface) == 0 "wayland-scanner bug: wl_surface is non-empty";
#assert size_of(wl_seat) == 0 "wayland-scanner bug: wl_seat is non-empty";
#assert size_of(wl_pointer) == 0 "wayland-scanner bug: wl_pointer is non-empty";
#assert size_of(wl_keyboard) == 0 "wayland-scanner bug: wl_keyboard is non-empty";
#assert size_of(wl_touch) == 0 "wayland-scanner bug: wl_touch is non-empty";
#assert size_of(wl_output) == 0 "wayland-scanner bug: wl_output is non-empty";
#assert size_of(wl_region) == 0 "wayland-scanner bug: wl_region is non-empty";
#assert size_of(wl_subcompositor) == 0 "wayland-scanner bug: wl_subcompositor is non-empty";
#assert size_of(wl_subsurface) == 0 "wayland-scanner bug: wl_subsurface is non-empty";
